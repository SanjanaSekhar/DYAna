//! \file analyze_LHE
//!
//! Code to read and analyze LHE files generated by Powheg/MadGraph



// Global definitions 

struct particle {         //!< individual particle structure
    int id;                 //! pdg particle id
    int status;             //! decay status
    int mother[2];          //! particle mother indices
    int color[2];           //!< color info
    double p[5];            //! 4-vector + mass
    float vtime;            //! lifetime
    float spin;             //! spin (helicity) info
} ;

struct eventcm {          //!< useful info in various frames
    double coststar;        //! t-scattering angle
    double mtt;             //! invariant mass of ttbar pair
    double xF;              //! Feynman x of ttbar pair
} ;

char *trimwhitespace(char *str)
{
  char *end;

  // Trim leading space
  while(isspace((unsigned char)*str)) str++;

  if(*str == 0)  // All spaces?
    return str;

  // Trim trailing space
  end = str + strlen(str) - 1;
  while(end > str && isspace((unsigned char)*end)) end--;

  // Write new null terminator
  *(end+1) = 0;

  return str;
}




// Main program  

void fill_tree(string f_name, TTree *t1, bool print = false)
    //reweight PYTHIA samples to get AFB for given Zprime mass at a given
    //dilepton mass
{
    // Local variables 
    int i, j, k, iqk=0, iqb=0, itq=0, itb=0, ig1=0, ig2=0, ijt, njet=0, npflavor=0, nevent, nfit;
    int iqk_extra = 0, iqb_extra=0;
    int nqqb=0, ngg=0, itbq, itbb, itqk, itqb, itlp, itnu;
    TLorentzVector lep_pls, lep_mns, q1, q2; // positive and negative lepton
    int nup, idrup, q1_id, q2_id;
    int lep1_id, lep2_id;
    float xwgtup, scalup, aqedup, aqcdup;
    double alpha;
    static char infile[80], header[80], inp1[200], outfile0[80], outfile1[80], outfile2[80];
    FILE *ifp;
    particle in;

    long deltas, deltaus;
    double deltat;

    t1->Branch("lep_pls", "TLorentzVector", &lep_pls);
    t1->Branch("lep_mns", "TLorentzVector", &lep_mns);
    t1->Branch("q1", "TLorentzVector", &q1);
    t1->Branch("q2", "TLorentzVector", &q2);
    t1->Branch("q1_id", &q1_id);
    t1->Branch("q2_id", &q2_id);
    t1->Branch("lep1_id", &lep1_id);
    t1->Branch("lep2_id", &lep2_id);
    t1->Branch("gen_weight", &xwgtup);

    // Construct file name to analyze




        // Make sure file is available 

    ifp = fopen(f_name.c_str(), "r");
    if (ifp==NULL) {
        printf("can't find %s\n",f_name.c_str());
        return -1.;
    }

    //  Book Histograms

    Int_t id;
    Double_t lep_pt, lep_eta, lep_phi, lep_E;
    double root2 = sqrt(2.);
    double Ebeam = 6500.;
    double Pbeam = sqrt(Ebeam*Ebeam - 0.938*0.938);

    nevent=0; nfit=0;
    int event_num =0;
    int nTotal =0;
    int nFail =0;
    Double_t nF = 0, nB = 0;
    Double_t n_utype=0, n_dtype=0;

    // Scan throught file first for the beginning of an event record	

    while (fgets(inp1, 200,ifp) !=NULL) {
        if(strstr(inp1,"<event") != NULL) {
            nTotal++;
            //printf("FOUND EVENT \n");
            event_num++;


            // event found


            // read event info

            fgets(inp1, 200, ifp);
            //char * line = trimwhitespace(inp1);
            //printf("line is %s \n", inp1);
            sscanf(inp1, "%d %d %f %f %f %f", &nup, &idrup, &xwgtup, &scalup, &aqedup, &aqcdup);
            //printf("nup is %i \n", nup
            //if(nup > 10) continue;


            // Make a vector to hold all particles for each event

            std::vector<particle> up;

            iqk = -1; iqb = -1; itq = -1; itb = -1; ig1 = -1; ig2 = -1; ijt = -1;
            iqk_extra = -1;
            iqb_extra = -1; //in case event with 2 quarks or 2 anti quarks
            njet = 0; npflavor = 0; nqqb = 0; ngg = 0;
            int qtype = 0; // type of quark, uct = 0 , dsb = 1

            int parton1 = -1, parton2 = -1;

            // Now loop over all particles

            for(i=0; i<nup; ++i) {
                if(fgets(inp1, 200, ifp) != NULL){
                    //printf("line is %s \n", inp1);
                    sscanf(inp1,"%d %d %d %d %d %d %lf %lf %lf %lf %lf %f %f", &in.id, &in.status, &in.mother[0], &in.mother[1],
                            &in.color[0], &in.color[1], &in.p[0], &in.p[1], &in.p[2], &in.p[3], &in.p[4], &in.vtime, &in.spin);	
                    up.push_back(in);
                }
                else{ printf("error reading particles \n");
                }
            } 

            //  Do event by event analysis here	

            // first, flag the stable final particles	   
            for(i=0; i<nup; ++i) {
                //printf("Status is %i \n", up[i].status);
                if(up[i].status == -1) {
                    if(parton1 == -1) parton1 = i;
                    else if(parton2 ==-1) parton2 = i;
                    else printf("Extra parton! \n");
                    if(up[i].id == 1 || (up[i].id == 2 || (up[i].id == 3 || (up[i].id == 4 || up[i].id == 5)))) {
                        if(iqk == -1){
                            iqk = i; 
                            
                        }
                        else{ 
                            iqk_extra = i;
                            //printf("Found double quark event \n");
                        }
                        continue;
                    }
                    if(up[i].id == -1 || (up[i].id == -2 || (up[i].id == -3|| (up[i].id == -4 || up[i].id == -5)))) {
                        if (iqb == -1) iqb = i; 
                        else{ 
                            iqb_extra = i;
                        }
                        continue;
                    }
                    if(ig1 == -1) {ig1 = i;} else {ig2 = i;}
                    continue;
                }
                if(up[i].id == 13 || up[i].id == 11 || up[i].id == 15) {itq = i; continue;}
                if(up[i].id == -13 || up[i].id == -11 || up[i].id == -15) {itb = i; continue;}

            }



            if(((iqk == -1) && (ig1 == -1 && iqb_extra == -1)) ||
               ((iqb == -1) && (ig1 == -1 && iqk_extra ==-1)) ||
                ((iqk == -1 && iqb == -1) && (ig2 == -1)) )   {
                printf("unable to determine initial state for event %i \n", event_num);
                printf("indices are %i %i %i %i \n", iqk, iqb, ig1, ig2);
                printf("printing particles \n");
                for(i=0; i<nup; i++){
                    printf("%d %d %d %d \n", up[i].id, up[i].status, up[i].mother[0], up[i].mother[1]);
                }
                nFail++;
                continue;
            }
            if(itq == -1 || itb == -1){
                printf("unable to determine leptons for event %i \n", event_num);
                printf("printing particles \n");
                for(i=0; i<nup; i++){
                    printf("%d %d %d %d \n", up[i].id, up[i].status, up[i].mother[0], up[i].mother[1]);
                }
                nFail++;
                continue;
            }

            if(abs(up[iqk].id) % 2 == 0) qtype = 0; //u-type quark
            else qtype = 1;
            
            q1_id = up[parton1].id;
            q2_id = up[parton2].id;
            lep1_id = up[itq].id;
            lep2_id = up[itb].id;
            
            //BACKWARDS PLS AND MNS DEFINITIONS
            lep_pls.SetPxPyPzE(up[itq].p[0], up[itq].p[1], up[itq].p[2], up[itq].p[3]);
            lep_mns.SetPxPyPzE(up[itb].p[0], up[itb].p[1], up[itb].p[2], up[itb].p[3]);

            q1.SetPxPyPzE(up[parton1].p[0], up[parton1].p[1], up[parton1].p[2], up[parton1].p[3]);
            q2.SetPxPyPzE(up[parton2].p[0], up[parton2].p[1], up[parton2].p[2], up[parton2].p[3]);
            nevent++;
            t1->Fill();


        }
    }

    /* close input file */

    fclose(ifp);

    Double_t AFB = ((nF - nB))/((nF+nB));
    Double_t dAFB = (1.-AFB*AFB)/sqrt((nF+nB));
    Double_t u_frac = n_utype/(n_utype + n_dtype);


    if(print){
        printf( "%i events failed to id \n", nFail);

        printf("Selected  %d out of %i events\n", nevent, nTotal);
        printf("\n");
    }



    return;
} 

